#!/usr/bin/env python3

# doctor -- diagnose and fix Karvus Environment as described by configuration.

import argparse
import os
import platform
import subprocess
import sys
import warnings
import yaml
import xdg
from voluptuous import Schema, Required, Invalid
from typing import Callable, TypedDict

if platform.system() != 'Linux':
   sys.exit("doctor currently only works on Linux systems")

# Constants

ZSH_LOCATION = '/usr/bin/zsh'
LASTPASS_LOGIN = 'karvus@gmail.com'
LASTPASS_RSA_ID = '2551172036'
LASTPASS_RSA_PUB_ID = '2551170726'
REPO_HTTPS = 'https://github.com/tstenhaug/dotfiles.git'
REPO_GIT = 'git@github.com:tstenhaug/dotfiles.git'
CONFIG_FILENAME = f'{xdg.xdg_config_home()}/ke/doctor.yml'
HOME=os.path.expanduser('~')

# Configuration

## Configuration elements

class Element:
   """Represents a configuration element"""

   def __init__(self, id, description, ask_for_value, diagnose, apply, schema_validator):
      self.id = id
      self.description = description
      self.ask_for_value = ask_for_value
      self.diagnose = diagnose
      self.apply = apply
      self.schema_validator = schema_validator

def get_element_list():
   return [
      Element(
         id='ssh-keys',
         description='Install default SSH private and public RSA keys',
         ask_for_value=ask_yn,
         diagnose=diagnose_ssh_keys,
         apply=install_ssh_keys,
         schema_validator=bool
      ),
   ]

def get_elements():
   return { elt.id: elt for elt in get_element_list() }

# Diagnostic

def diagnose_file(filename, permissions, exist_test=os.path.isfile):
   if not exist_test(filename):
      warn(f'{filename} is missing')
   else:
      if mod(filename) != permissions:
         warn(f'{filename} exists but have incorrect permissions')
      else:
         info(f'{filename} exists and have correct permissions')
         return True
   return False

def diagnose_ssh_keys(config_value: bool):
   ssh = f'{HOME}/.ssh'
   id_rsa = f'{ssh}/id_rsa'
   id_rsa_pub = f'{id_rsa}.pub'
   if not diagnose_file(ssh, 0o700, exist_test=os.path.isdir):
      return False
   else:
      return diagnose_file(id_rsa, 0o600) and diagnose_file(id_rsa_pub, 0o600)

def diagnose_nvim(config_value: bool):
   warnings.warn('diagnose_nvim is a stub')

def diagnose_against_config(config, elements):
   """Run diagnostics for all configured elements."""
   info('running diagnostics against current configuration')
   for config_id, config_value in config.items():
      if not config_value:
         info(f'{config_id}: skipping')
      else:
         elt = elements[config_id]
         info(f'=== {config_id} ===')
         elt.diagnose(config_value)

# Applicators -- functions that apply configuration elements

def install_ssh_keys(val: bool):
   warnings.warn('install_ssh_keys is a stub')

def configure_nvim(val: bool):
   warnings.warn('configure_nvim is a stub')

# Prompters (askers)

def ask_yn(prompt: str):
   while True:
      ans = input(prompt + ' (y/n) ')
      if ans in ['y', 'n']:
         return ans == 'y'

# Validation

def validate_or_die(config, config_schema):
   try:
      config_schema(config)
   except Invalid as e:
      error(f'invalid configuration: {config}')
      error(e)
      exit(1)
   return True

def get_config_schema(element_list=get_element_list()):
   return Schema({
      Required(element.id): element.schema_validator for element in element_list
})

# Printers

ANSI_GREEN = u'\u001b[32m'
ANSI_RED = u'\u001b[31m'
ANSI_YELLOW = u'\u001b[33m'
ANSI_RESET = u'\u001b[0m'

def info(msg, newline=True):
   print(f'{ANSI_GREEN}DOCTOR{ANSI_RESET}:',
         msg,
         end = '\n' if newline else '')

def warn(msg, newline=True):
   if not newline:
      end = ''
   print(f'{ANSI_YELLOW}DOCTOR-WARNING{ANSI_RESET}:', msg, file=sys.stderr)

def error(msg, newline=True):
   if not newline:
      end = ''
   print(f'{ANSI_RED}DOCTOR-ERROR{ANSI_RESET}:', msg, file=sys.stderr)

# Commands

def ask_config(elements):
   """Prompt for values for all configuration elements."""
   config = {}
   for elt in elements.values():
      config[elt.id] = elt.ask_for_value(elt.description)
   validate_or_die(config, get_config_schema())
   return config

def apply_config(config, elements):
   """Apply configuration elements to the system."""
   for id, config_value in config.items():
      elements[id].apply(config_value)

# Helpers

def load_config(config_file):
   if not os.path.isfile(config_file):
      error('config file not found; try running doctor with --configure')
      exit(1)
   else:
      with open(config_file) as file:
         config = yaml.load(file, Loader=yaml.FullLoader)
         validate_or_die(config, get_config_schema())
         return config

def write_config(config, config_filename=CONFIG_FILENAME):
   info(f'writing config to {config_filename}')
   dirname = os.path.dirname(config_filename)
   if not os.path.isdir(dirname):
      os.makedirs(dirname)
   with open(config_filename, 'w') as file:
      file.write(yaml.dump(config))

def mod(filename):
   """Return the access ("mod") bits of filename"""
   return os.stat(filename).st_mode & 0o777

# Argument parsing

def get_parser():
   parser = argparse.ArgumentParser(
      description =
      'Diagnose and fix Karvus Environment as described by configuration.'
      )
   parser.add_argument('--configure', dest='configure', action='store_true',
                       help='invoke configuration wizard')
   parser.add_argument('--apply', dest='apply', action='store_true',
                       help='apply configuration')
   return parser


# Main

if __name__ == '__main__':

   args = get_parser().parse_args()

   if args.configure:
      config = ask_config(get_elements())
      write_config(config)
   else:
      config = load_config(CONFIG_FILENAME)

   diagnose_against_config(config, get_elements())

   if args.apply:
      apply_config(config, get_elements())


# It seems

# # try to figure out which distro we're on
# determine_distro() {
#     if [ -e /etc/arch-release ] ; then
#         distro=arch
#     else if [ -f  /etc/system-release ] && egrep "CentOS|Fedora" /etc/system-release &> /dev/null ; then
#              distro=rhel_like
#          else
#              distro=unknown
#          fi
#     fi
#     info "Determined distro: ${distro}"
# }

# # set_distro_vars <distro>
# set_distro_vars() {
#     case "$1" in
#        arch)
#          install_command="sudo pacman -S"
#          query_command="pacman -Q"
#          zsh_package="zsh"
# 		 neovim_package="neovim"
#          lastpass_package="lastpass-cli"
#          ;;
#        rhel)
#            install_command="sudo dnf install"
#            query_command="dnf list installed"
#            python_package="python39"
#            zsh_package="zsh"
# 		   neovim_package="neovim.x86_64"
#            lastpass_package="lastpass-cli.x86_64"
#            ;;
#        unknown)
#            info "Unknown distro, will not be able to install packages"
#            ;;
#        *)
#            error "Distro has been determined, but variables for it not defined"
#     esac
# }

# # info <message>
# info() {
#     echo DOC: $*
# }

# # error <message>
# error() {
#     echo "DOC-ERR: $*"
#     exit 1
# }

# is_ssh_keys_installed() {
#     if [ -d ~/.ssh ]  && [ -e ~/.ssh/id_rsa ] && [ -e ~/.ssh/id_rsa.pub ] ; then
#         return 0
#     else
#         return 1
#  fi
# }

# is_zsh_installed() {
#     command -v zsh &> /dev/null
# }

# is_zsh_my_shell() {
#     [ $(grep $USER /etc/passwd | cut -d : -f 7) = $ZSH_LOCATION ]
# }

# is_nvim_installed() {
#     command -v nvim &> /dev/null
# }

# # extract id_rsa and id_rsa.pub from my lastpass account
# extract_ssh_keys() {
#     if ! [ -d ~/.ssh ] ; then
#         info "~/.ssh missing, creating and chmoding"
#         mkdir ~/.ssh
#         chmod 700 ~/.ssh
#     fi
#     if ! lpass info | grep "Logged in as $LASTPASS_LOGIN" &> /dev/null
#     then
#         lpass login "${LASTPASS_LOGIN}"
#     fi
#     lpass show --notes ${LASTPASS_RSA_ID} > ~/.ssh/id_rsa
#     chmod 600 ~/.ssh/id_rsa
#     lpass show --notes ${LASTPASS_RSA_PUB_ID} > ~/.ssh/id_rsa.pub
#     info "SSH keys extracted"
# }

# # install_package <package_name>
# install_package() {
#     package_name=$1
#    if [ "${install_command}" = "" ] ; then
#         error "No install command set"
#     fi
#     if [ "${package_name}" = "" ] ; then
#         error "$0: no package name supplied"
#     fi
#     eval $install_command $package_name
# }

# # main

# determine_distro
# set_distro_vars ${distro}

# if ! command -v git &> /dev/null ; then
#     error "git not installed"
#     exit 1
# fi

# if ! command -v ssh &> /dev/null ; then
#     error "ssh not installed"
#     exit 1
# fi

# if ! is_ssh_keys_installed ; then
#     info SSH-keys not installed, trying to extract with lastpass
#     if ! which lpass &> /dev/null ; then
#         if install_package ${lastpass_package} ; then
#             extract_ssh_keys
#         fi
#     else
#         extract_ssh_keys
#     fi
# else
#     info SSH keys already installed
# fi

# # if yadm repo origin is https, switch to git
# if yadm remote get-url origin | grep ${REPO_HTTPS} &> /dev/null ; then
#     info "YADM repo is tracking the HTTPS url, changing to git"
#     yadm remote set-url origin ${REPO_GIT}
# else
#     info "YADM repo is tracking the git url"
# fi

# if is_zsh_installed ; then
#     info "zsh already installed"
# else
#     info "zsh not installed, trying to install"
#     install_package ${zsh_package}
# fi

# if is_zsh_my_shell ; then
#     info "zsh is my shell"
# else
#     info "zsh is not my shell, changing"
#     chsh -s /usr/bin/zsh
# fi

# if is_nvim_installed ; then
# 	info "Neovim is installed"
# else
#     info "Neovim is not installed, rectifying"
# 	install_package ${neovim_package}
# fi

# if test -e "${NVIM_VIM_PLUG_LOCATION}"  ; then
# 	info "Neovim: vim-plug is installed"
# else
# 	info "Neovim: vim-plug is not installed, rectifying"
# 	curl -fLo "${NVIM_VIM_PLUG_LOCATION}" --create-dirs "${NVIM_VIM_PLUG_URL}"
# fi

# info "Neovim: installing plugins"
# nvim --headless -c PlugInstall -c q! -c q! 2> /dev/null
